const express = require('express');
const mongoose = require('mongoose');
const router = express.Router();
const auth = require('../middleware/auth');
const bcrypt = require('bcryptjs');
const User = require('../models/User');
const CaseReport = require('../models/CaseReport');
const Case = require('../models/Case');
const Notification = require('../models/Notification');
const { notifyAdmins, notifyCaseStakeholders } = require('../utils/notificationHelper');
const { getUserTaskBasedCases, hasAnyCaseAccess } = require('../utils/caseAccessHelper');

// Helper to create automated report
const createAutomatedReport = async (caseId, userId, actionType, extra = {}) => {
    try {
        const user = await User.findById(userId);
        const userName = user ? user.name || user.email || userId : 'Unknown User';

        let content = '';
        switch (actionType) {
            case 'Creation':
                content = `Case created by ${userName}`;
                break;
            case 'Assignment':
                let assigneeName = 'Head of Chambers';
                if (extra.assigneeId) {
                    const assignee = await User.findById(extra.assigneeId);
                    if (assignee) assigneeName = assignee.name || assignee.email;
                }
                content = `Case assigned to ${assigneeName} - HOC`;
                break;
            case 'LawyerAssignment':
                content = `Lawyers assigned to case by ${userName}`;
                break;
            case 'StatusChange':
                const { oldStatus, newStatus } = extra;
                content = `${userName} Changed the case status to ${newStatus}`;
                break;
            case 'CourtUpdate':
                content = `${userName} Added a new court detail`;
                break;
            case 'OpposingCounselUpdate':
                content = `${userName} Added a new opposition counsel`;
                break;
            default:
                content = `Report generated by ${userName}`;
        }
        const report = new CaseReport({
            case: caseId,
            author: userId,
            content,
            type: 'Automated',
            actionType: actionType === 'LawyerAssignment' ? 'Assignment' : actionType
        });
        await report.save();
    } catch (err) {
        console.error('Error creating automated report:', err.message);
    }
};





// @route   POST /api/cases
// @desc    Create a new case
// @access  Private (HOC and Superadmin only)
router.post('/', auth, async (req, res) => {
    try {
        // Check if user is HOC or Superadmin
        const user = await User.findById(req.user.id);
        if (!user || (user.role !== 'HOC' && user.role !== 'Superadmin')) {
            return res.status(403).json({ msg: 'Only HOC and Superadmin can create cases' });
        }

        const {
            clientId,
            caseType,
            subCategory,
            caseTitle,
            summary,
            dateIssueStarted,
            clientObjective,
            parties,
            opposingCounsel,
            witnesses,
            inCourt,
            courtName,
            courtLocation,
            caseNumber,
            presidingJudge,
            nextCourtDate,
            previousOrders
        } = req.body;

        // Create new case
        const newCase = new Case({
            client: clientId,
            caseType,
            subCategory,
            caseTitle,
            summary,
            dateIssueStarted,
            clientObjective,
            parties,
            // Map single opposingCounsel string to history array
            opposingCounselHistory: opposingCounsel ? [{
                name: opposingCounsel,
                dateAdded: new Date()
            }] : [],
            witnesses,
            inCourt,
            courtInfo: inCourt ? [{
                courtName,
                courtLocation,
                caseNumber,
                presidingJudge,
                nextCourtDate,
                previousOrders,
                dateAdded: new Date()
            }] : [],
            createdBy: req.user.id,
            assignedTo: user.role === 'HOC' ? req.user.id : undefined
        });

        const savedCase = await newCase.save();

        // Create automated report
        await createAutomatedReport(
            savedCase._id,
            req.user.id,
            'Creation'
        );

        // Notify admins about new case
        const populatedCase = await Case.findById(savedCase._id).populate('client', 'name');
        await notifyAdmins(
            'case_created',
            `New case created: ${caseTitle} for ${populatedCase.client?.name || 'Unknown Client'}`,
            {
                entityType: 'Case',
                entityId: savedCase._id
            }
        );

        // Notify client about their new case
        await new Notification({
            recipient: clientId,
            type: 'client_case_created',
            message: `New case created for you: "${caseTitle}"`,
            relatedEntity: {
                entityType: 'Case',
                entityId: savedCase._id
            }
        }).save();

        res.json(savedCase);

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   GET /api/cases
// @desc    Get all cases (with optional filters)
// @access  Private
router.get('/', auth, async (req, res) => {
    try {
        const userId = req.user.id;
        const user = await User.findById(userId);

        // Get directly assigned cases based on role
        let directCases = [];

        if (user.role === 'Admin' || user.role === 'HOC' || user.role === 'Superadmin') {
            // Admins, HOC, and Superadmins see all cases
            directCases = await Case.find()
                .populate('client', 'name email')
                .populate('assignedTo', 'name email')
                .populate('assignedLawyers', 'name email')
                .populate('assignedParalegals', 'name email')
                .sort({ createdAt: -1 });
        } else if (user.role === 'Lawyer') {
            // Lawyers see cases they're assigned to
            directCases = await Case.find({
                assignedLawyers: userId
            })
                .populate('client', 'name email')
                .populate('assignedTo', 'name email')
                .populate('assignedLawyers', 'name email')
                .populate('assignedParalegals', 'name email')
                .sort({ createdAt: -1 });
        } else if (user.role === 'Paralegal') {
            // Paralegals see cases they're assigned to
            directCases = await Case.find({
                assignedParalegals: userId
            })
                .populate('client', 'name email')
                .populate('assignedTo', 'name email')
                .populate('assignedLawyers', 'name email')
                .populate('assignedParalegals', 'name email')
                .sort({ createdAt: -1 });
        }

        // Get task-based access cases
        const taskBasedCases = await getUserTaskBasedCases(userId);

        // Mark direct cases
        const directCasesWithType = directCases.map(c => ({
            ...c.toObject(),
            accessType: 'direct'
        }));

        // Merge and deduplicate (direct access takes precedence)
        const directCaseIds = new Set(directCases.map(c => c._id.toString()));
        const uniqueTaskCases = taskBasedCases.filter(
            tc => !directCaseIds.has(tc._id.toString())
        );

        const allCases = [...directCasesWithType, ...uniqueTaskCases];

        res.json(allCases);

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   GET /api/cases/client/:clientId
// @desc    Get all cases for a specific client
// @access  Private
router.get('/client/:clientId', auth, async (req, res) => {
    try {
        const cases = await Case.find({ client: req.params.clientId })
            .sort({ createdAt: -1 });

        res.json(cases);

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   GET /api/cases/:id
// @desc    Get case by ID
// @access  Private
router.get('/:id', auth, async (req, res) => {
    try {
        const caseItem = await Case.findById(req.params.id)
            .populate('client', 'name email phone address occupation dateOfBirth')
            .populate('assignedTo', 'name email')
            .populate('assignedLawyers', 'name email')
            .populate('assignedParalegals', 'name email');

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Check if user has access (direct or task-based)
        const userId = req.user.id;
        const user = await User.findById(userId);

        // Admins, HOC, and Superadmins have access to all cases
        const isAdmin = ['Admin', 'HOC', 'Superadmin'].includes(user.role);

        if (!isAdmin) {
            // Check if user has any access to this case
            const hasAccess = await hasAnyCaseAccess(req.params.id, userId);

            if (!hasAccess) {
                return res.status(403).json({ msg: 'Access denied to this case' });
            }
        }

        // Auto-generate shareToken if missing (for legacy cases)
        if (!caseItem.shareToken) {
            await caseItem.save(); // Pre-save hook will generate the token
        }

        res.json(caseItem);

    } catch (err) {
        console.error(err.message);
        if (err.kind === 'ObjectId') {
            return res.status(404).json({ msg: 'Case not found' });
        }
        res.status(500).send('Server Error');
    }
});



// @route   PUT /api/cases/:id/court-details
// @desc    Update court details (Allowed for Admin, HOC, Superadmin)
// @access  Private
router.put('/:id/court-details', auth, async (req, res) => {
    try {
        const user = await User.findById(req.user.id);
        if (!user) {
            return res.status(401).json({ msg: 'User not found' });
        }

        // Allow Admin, HOC, Superadmin
        if (!['Admin', 'HOC', 'Superadmin'].includes(user.role)) {
            return res.status(403).json({ msg: 'Not authorized to update court details' });
        }

        const caseItem = await Case.findById(req.params.id);
        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Initialize courtInfo as empty array if it's null
        if (caseItem.courtInfo === null || caseItem.courtInfo === undefined) {
            caseItem.courtInfo = [];
            await caseItem.save();
        }

        // MIGRATION CHECK: Ensure courtInfo is an array
        if (caseItem.courtInfo && !Array.isArray(caseItem.courtInfo)) {
            const legacyInfo = caseItem.courtInfo;
            if (!legacyInfo.dateAdded) {
                legacyInfo.dateAdded = caseItem.updatedAt || new Date();
            }
            await Case.collection.updateOne(
                { _id: new mongoose.Types.ObjectId(req.params.id) },
                { $set: { courtInfo: [legacyInfo] } }
            );
        }

        const action = req.body.courtInfoAction || 'legacy'; // 'add', 'edit'
        const courtInfoData = req.body.courtInfo;

        if (action === 'add') {
            // Add new court info entry
            await Case.findByIdAndUpdate(
                req.params.id,
                {
                    $push: { courtInfo: courtInfoData },
                    $set: { inCourt: true }
                }
            );
        } else if (action === 'edit') {
            // Update the LAST entry in the courtInfo array
            const currentCase = await Case.findById(req.params.id);
            if (currentCase && currentCase.courtInfo && currentCase.courtInfo.length > 0) {
                const lastIndex = currentCase.courtInfo.length - 1;
                const updateField = {};
                for (const [key, value] of Object.entries(courtInfoData)) {
                    updateField[`courtInfo.${lastIndex}.${key}`] = value;
                }
                await Case.findByIdAndUpdate(
                    req.params.id,
                    { $set: updateField }
                );
            }
        } else {
            // Legacy/Default behavior (same as edit/add logic combined)
            const currentCase = await Case.findById(req.params.id);
            if (!currentCase.courtInfo || currentCase.courtInfo.length === 0) {
                await Case.findByIdAndUpdate(
                    req.params.id,
                    {
                        $push: { courtInfo: courtInfoData },
                        $set: { inCourt: true }
                    }
                );
            } else {
                const lastIndex = currentCase.courtInfo.length - 1;
                const updateField = {};
                for (const [key, value] of Object.entries(courtInfoData)) {
                    updateField[`courtInfo.${lastIndex}.${key}`] = value;
                }
                await Case.findByIdAndUpdate(
                    req.params.id,
                    { $set: updateField }
                );
            }
        }

        // Notify stakeholders
        try {
            await notifyCaseStakeholders(
                req.params.id,
                'court_update',
                `Court details updated for case: ${caseItem.caseTitle}`,
                {
                    entityType: 'Case',
                    entityId: req.params.id,
                    actionBy: user._id
                }
            );
        } catch (stakeholderErr) {
            console.error('Error notifying stakeholders:', stakeholderErr.message);
        }

        // Notify client about court update
        try {
            if (caseItem.client) {
                await new Notification({
                    recipient: caseItem.client,
                    type: 'client_court_update',
                    message: `Court details updated for your case: "${caseItem.caseTitle}"`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: req.params.id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error creating court update notification:', notifErr.message);
            // Continue even if notification fails
        }

        // Create automated report
        await createAutomatedReport(
            req.params.id,
            user._id,
            'CourtUpdate',
            { details: 'Court details updated' }
        );

        const updatedCase = await Case.findById(req.params.id)
            .populate('client', 'name email phone')
            .populate('assignedTo', 'name email')
            .populate('assignedLawyers', 'name email');

        res.json(updatedCase);

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   PUT /api/cases/:id
// @desc    Update case
// @access  Private (HOC and Superadmin for full updates, Admin for status only)
router.put('/:id', auth, async (req, res) => {
    try {
        // Check user role
        const user = await User.findById(req.user.id);
        if (!user) {
            return res.status(401).json({ msg: 'User not found' });
        }

        // If user is Admin, only allow status updates
        if (user.role === 'Admin') {
            // Admin can only update status, and should use the dedicated status endpoint
            return res.status(403).json({ msg: 'Admin users can only change case status via the status endpoint' });
        }

        // Only HOC and Superadmin can proceed with full case updates
        if (user.role !== 'HOC' && user.role !== 'Superadmin') {
            return res.status(403).json({ msg: 'Only HOC and Superadmin can edit cases' });
        }

        let caseItem = await Case.findById(req.params.id).populate('assignedTo', 'name');

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Track changes for notifications
        const oldStatus = caseItem.status;
        const oldAssignedTo = caseItem.assignedTo?._id?.toString();
        const newStatus = req.body.status;
        const newAssignedTo = req.body.assignedTo;

        // Handle court info updates specifically
        if (req.body.courtInfo) {
            // MIGRATION CHECK: Simple JS-based check
            try {
                const rawCase = await Case.collection.findOne({ _id: new mongoose.Types.ObjectId(req.params.id) });
                // Check if courtInfo exists and is NOT an array (i.e., it's the legacy object)
                if (rawCase && rawCase.courtInfo && !Array.isArray(rawCase.courtInfo)) {
                    const legacyInfo = rawCase.courtInfo;
                    if (!legacyInfo.dateAdded) {
                        legacyInfo.dateAdded = rawCase.updatedAt || new Date();
                    }

                    await Case.collection.updateOne(
                        { _id: new mongoose.Types.ObjectId(req.params.id) },
                        { $set: { courtInfo: [legacyInfo] } }
                    );
                }
            } catch (migrationErr) {
                console.error("Migration check failed:", migrationErr);
            }

            const action = req.body.courtInfoAction || 'legacy'; // 'add', 'edit', or 'legacy'

            if (action === 'add') {
                // Add new court info entry
                await Case.findByIdAndUpdate(
                    req.params.id,
                    {
                        $push: { courtInfo: req.body.courtInfo },
                        $set: { inCourt: true } // Ensure inCourt is true
                    }
                );
            } else if (action === 'edit') {
                // Update the LAST entry in the courtInfo array
                const currentCase = await Case.findById(req.params.id);
                if (currentCase && currentCase.courtInfo && currentCase.courtInfo.length > 0) {
                    const lastIndex = currentCase.courtInfo.length - 1;
                    const updateField = {};
                    for (const [key, value] of Object.entries(req.body.courtInfo)) {
                        updateField[`courtInfo.${lastIndex}.${key}`] = value;
                    }

                    await Case.findByIdAndUpdate(
                        req.params.id,
                        { $set: updateField }
                    );
                }
            } else {
                // Legacy/Default behavior
                const currentCase = await Case.findById(req.params.id);
                if (!currentCase.courtInfo || currentCase.courtInfo.length === 0) {
                    await Case.findByIdAndUpdate(
                        req.params.id,
                        {
                            $push: { courtInfo: req.body.courtInfo },
                            $set: { inCourt: true }
                        }
                    );
                } else {
                    // Update last entry
                    const lastIndex = currentCase.courtInfo.length - 1;
                    const updateField = {};
                    for (const [key, value] of Object.entries(req.body.courtInfo)) {
                        updateField[`courtInfo.${lastIndex}.${key}`] = value;
                    }
                    await Case.findByIdAndUpdate(
                        req.params.id,
                        { $set: updateField }
                    );
                }
            }

            // Remove courtInfo from req.body to prevent overwriting with the $set below if it was passed as a top level field
            delete req.body.courtInfo;
            delete req.body.courtInfoAction;

            // Notify all case stakeholders about court update
            const userName = user?.name || 'Someone';
            await notifyCaseStakeholders(
                req.params.id,
                'court_update',
                `${userName} added/updated court date for case "${caseItem.caseTitle}"`
            );
        }

        // Update other fields
        caseItem = await Case.findByIdAndUpdate(
            req.params.id,
            { $set: req.body },
            { new: true }
        ).populate('assignedTo', 'name');

        // Notify admins if status changed
        if (newStatus && oldStatus !== newStatus) {
            await notifyAdmins(
                'case_status_changed',
                `Case "${caseItem.caseTitle}" status changed to ${newStatus}`,
                {
                    entityType: 'Case',
                    entityId: caseItem._id
                }
            );
        }

        // Notify admins if HOC assignment changed
        if (newAssignedTo && oldAssignedTo !== newAssignedTo) {
            await notifyAdmins(
                'case_assigned',
                `Case "${caseItem.caseTitle}" assigned to ${caseItem.assignedTo?.name || 'HOC'}`,
                {
                    entityType: 'Case',
                    entityId: caseItem._id
                }
            );
        }

        // Notify all stakeholders if case was edited (excluding status/assignment changes which have their own notifications)
        if (!newStatus && !newAssignedTo && !req.body.courtInfo) {
            const userName = user?.name || 'Someone';
            await notifyCaseStakeholders(
                req.params.id,
                'case_updated',
                `${userName} updated case "${caseItem.caseTitle}"`
            );

            // Notify client about case update
            try {
                if (caseItem.client) {
                    await new Notification({
                        recipient: caseItem.client,
                        type: 'client_case_updated',
                        message: `Your case "${caseItem.caseTitle}" has been updated`,
                        relatedEntity: {
                            entityType: 'Case',
                            entityId: caseItem._id
                        }
                    }).save();
                }
            } catch (notifErr) {
                console.error('Error creating case update notification:', notifErr.message);
            }
        }

        res.json(caseItem);

    } catch (err) {
        console.error(err.message);
        if (err.kind === 'ObjectId') {
            return res.status(404).json({ msg: 'Case not found' });
        }
        res.status(500).send('Server Error');
    }
});

// @route   DELETE /api/cases/:id
// @desc    Delete case
// @access  Private
router.delete('/:id', auth, async (req, res) => {
    try {
        const caseItem = await Case.findById(req.params.id);

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        await Case.findByIdAndDelete(req.params.id);

        res.json({ msg: 'Case deleted' });

    } catch (err) {
        console.error(err.message);
        if (err.kind === 'ObjectId') {
            return res.status(404).json({ msg: 'Case not found' });
        }
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/:id/assign
// @desc    Assign case to HOC
// @access  Private
router.post('/:id/assign', auth, async (req, res) => {
    try {
        const { hocId } = req.body;
        const hocUser = await User.findById(hocId);
        const hocName = hocUser ? hocUser.name : 'Unknown HOC';

        const caseItem = await Case.findById(req.params.id);

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Update case with assignment
        caseItem.assignedTo = hocId;
        caseItem.assignedAt = Date.now();
        await caseItem.save();

        // Create automated report
        await createAutomatedReport(
            caseItem._id,
            req.user.id,
            'Assignment',
            { assigneeId: hocId }
        );

        // Create notification for HOC (with error handling)
        try {
            const Notification = require('../models/Notification');
            const notification = new Notification({
                recipient: hocId,
                message: `New case "${caseItem.caseTitle}" has been assigned to you`,
                type: 'case_assignment',
                relatedEntity: {
                    entityType: 'Case',
                    entityId: caseItem._id
                }
            });
            await notification.save();
        } catch (notifErr) {
            console.error('Error creating notification:', notifErr.message);
            // Continue even if notification fails
        }

        // Notify admins about case assignment
        await notifyAdmins(
            'case_assigned',
            `Case "${caseItem.caseTitle}" assigned to ${hocName} (HOC)`,
            {
                entityType: 'Case',
                entityId: caseItem._id
            }
        );

        res.json({ msg: 'Case assigned successfully', case: caseItem });

    } catch (err) {
        console.error('Assignment error:', err.message);
        console.error(err.stack);
        if (err.kind === 'ObjectId') {
            return res.status(404).json({ msg: 'Case not found' });
        }
        res.status(500).json({ msg: 'Server Error', error: err.message });
    }
});

// @route   POST /api/cases/:id/status
// @desc    Update case status
// @access  Private
router.post('/:id/status', auth, async (req, res) => {
    try {
        const { status } = req.body;

        const caseItem = await Case.findById(req.params.id);

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        const oldStatus = caseItem.status;
        caseItem.status = status;
        await caseItem.save();

        // Create automated report
        await createAutomatedReport(
            caseItem._id,
            req.user.id,
            'StatusChange',
            { oldStatus, newStatus: status }
        );

        // Notify admins about status change
        await notifyAdmins(
            'case_status_changed',
            `Case "${caseItem.caseTitle}" status changed to ${status}`,
            {
                entityType: 'Case',
                entityId: caseItem._id
            }
        );

        // Notify client about status change
        try {
            if (caseItem.client) {
                await new Notification({
                    recipient: caseItem.client,
                    type: 'client_case_status_changed',
                    message: `Your case "${caseItem.caseTitle}" status changed to: ${status}`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error creating status change notification:', notifErr.message);
        }

        res.json({ msg: 'Status updated successfully', case: caseItem });

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/:id/assign-lawyers
// @desc    Assign lawyers to case
// @access  Private
router.post('/:id/assign-lawyers', auth, async (req, res) => {
    try {
        const { lawyerIds } = req.body;

        const caseItem = await Case.findById(req.params.id);

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Get current lawyers before update
        const oldLawyerIds = caseItem.assignedLawyers.map(id => id.toString());
        const newLawyerIds = lawyerIds.map(id => id.toString());

        // Detect added and removed lawyers
        const addedLawyers = newLawyerIds.filter(id => !oldLawyerIds.includes(id));
        const removedLawyers = oldLawyerIds.filter(id => !newLawyerIds.includes(id));

        // Update the case
        caseItem.assignedLawyers = lawyerIds;
        await caseItem.save();

        const user = await User.findById(req.user.id);
        const userName = user?.name || 'Someone';

        // Create automated report and notification for added lawyers
        if (addedLawyers.length > 0) {
            await createAutomatedReport(
                caseItem._id,
                req.user.id,
                'LawyerAssignment'
            );

            await notifyCaseStakeholders(
                req.params.id,
                'lawyers_assigned',
                `${userName} assigned lawyers to case "${caseItem.caseTitle}"`
            );
        }

        // Create automated report and notification for removed lawyers
        if (removedLawyers.length > 0) {
            // Create report for lawyer removal
            const report = new CaseReport({
                case: caseItem._id,
                author: req.user.id,
                content: `${userName} removed lawyers from the case`,
                type: 'Automated',
                actionType: 'Assignment'
            });
            await report.save();

            await notifyCaseStakeholders(
                req.params.id,
                'lawyers_removed',
                `${userName} removed lawyers from case "${caseItem.caseTitle}"`
            );
        }

        res.json({ msg: 'Lawyers assigned successfully', case: caseItem });

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/:id/assign-paralegals
// @desc    Assign paralegals to case
// @access  Private (Lawyers only)
router.post('/:id/assign-paralegals', auth, async (req, res) => {
    try {
        const { paralegalIds } = req.body;

        // Check if user is a Lawyer, HOC, or Admin
        const user = await User.findById(req.user.id);
        if (!user || !['Lawyer', 'HOC', 'Admin'].includes(user.role)) {
            return res.status(403).json({ msg: 'Only Lawyers, HOC, and Admin can assign paralegals' });
        }

        const caseItem = await Case.findById(req.params.id);

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Verify permissions based on role
        if (user.role === 'Lawyer') {
            // Lawyers can only assign paralegals to cases they're assigned to
            const isAssignedLawyer = caseItem.assignedLawyers.some(
                lawyerId => lawyerId.toString() === req.user.id
            );

            if (!isAssignedLawyer) {
                return res.status(403).json({ msg: 'You are not assigned to this case' });
            }
        }
        // HOC and Admin have full access to all cases

        // Get current paralegals before update
        const oldParalegalIds = caseItem.assignedParalegals.map(id => id.toString());
        const newParalegalIds = paralegalIds.map(id => id.toString());

        // Detect added and removed paralegals
        const addedParalegals = newParalegalIds.filter(id => !oldParalegalIds.includes(id));
        const removedParalegals = oldParalegalIds.filter(id => !newParalegalIds.includes(id));

        // Update the case
        caseItem.assignedParalegals = paralegalIds;
        await caseItem.save();

        const userName = user?.name || 'Someone';

        // Create automated report and notification for added paralegals
        if (addedParalegals.length > 0) {
            // Create automated report
            const report = new CaseReport({
                case: caseItem._id,
                author: req.user.id,
                content: `${userName} assigned paralegals to the case`,
                type: 'Automated',
                actionType: 'Assignment'
            });
            await report.save();

            // Notify each added paralegal
            for (const paralegalId of addedParalegals) {
                try {
                    await new Notification({
                        recipient: paralegalId,
                        message: `You have been assigned to case "${caseItem.caseTitle}" by ${userName}`,
                        type: 'case_assignment',
                        relatedEntity: {
                            entityType: 'Case',
                            entityId: caseItem._id
                        }
                    }).save();
                } catch (notifErr) {
                    console.error('Error notifying paralegal:', notifErr.message);
                }
            }

            // Notify case stakeholders
            await notifyCaseStakeholders(
                req.params.id,
                'paralegals_assigned',
                `${userName} assigned paralegals to case "${caseItem.caseTitle}"`
            );
        }

        // Create automated report for removed paralegals
        if (removedParalegals.length > 0) {
            const report = new CaseReport({
                case: caseItem._id,
                author: req.user.id,
                content: `${userName} removed paralegals from the case`,
                type: 'Automated',
                actionType: 'Assignment'
            });
            await report.save();

            await notifyCaseStakeholders(
                req.params.id,
                'paralegals_removed',
                `${userName} removed paralegals from case "${caseItem.caseTitle}"`
            );
        }

        res.json({ msg: 'Paralegals assigned successfully', case: caseItem });

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});


// @route   GET /api/cases/:id/reports
// @desc    Get all reports for a case
// @access  Private
router.get('/:id/reports', auth, async (req, res) => {
    try {
        const reports = await CaseReport.find({ case: req.params.id })
            .populate('author', 'name email role')
            .sort({ createdAt: -1 });

        res.json(reports);
    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/:id/reports
// @desc    Create a manual report
// @access  Private
router.post('/:id/reports', auth, async (req, res) => {
    try {
        const { content } = req.body;

        const report = new CaseReport({
            case: req.params.id,
            author: req.user.id,
            content,
            type: 'Manual'
        });

        await report.save();

        // Populate author details for immediate frontend display
        await report.populate('author', 'name email role');

        // Notify all case stakeholders about the new report
        const caseItem = await Case.findById(req.params.id);
        const authorName = report.author?.name || 'Someone';
        await notifyCaseStakeholders(
            req.params.id,
            'case_report_added',
            `${authorName} added a report to case "${caseItem?.caseTitle || 'Unknown'}"`,
            req.user.id
        );

        // Notify client about the new report
        try {
            if (caseItem && caseItem.client) {
                await new Notification({
                    recipient: caseItem.client,
                    type: 'client_report_added',
                    message: `New report added to your case: "${caseItem.caseTitle}"`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error creating client report notification:', notifErr.message);
        }

        // Notify all managers about the new report
        try {
            const managers = await User.find({ role: 'Manager' });
            const managerNotifications = managers.map(manager => ({
                recipient: manager._id,
                type: 'case_report_added',
                message: `${authorName} added a report to case "${caseItem?.caseTitle || 'Unknown'}"`,
                relatedEntity: {
                    entityType: 'Case',
                    entityId: caseItem._id
                }
            }));

            if (managerNotifications.length > 0) {
                await Notification.insertMany(managerNotifications);
            }
        } catch (notifErr) {
            console.error('Error creating manager report notifications:', notifErr.message);
        }

        // Notify HOC (report author) that their report was sent
        try {
            if (req.user.id) {
                await new Notification({
                    recipient: req.user.id,
                    type: 'case_report_added',
                    message: `Your report for case "${caseItem?.caseTitle || 'Unknown'}" has been sent`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error creating HOC report confirmation:', notifErr.message);
        }

        res.json(report);

    } catch (err) {
        console.error(err.message);
        res.status(500).send('Server Error');
    }
});

// ==================== CLIENT PORTAL ROUTES ====================

// @route   POST /api/cases/shared/:token/setup-pin
// @desc    First-time setup: Verify client name and set PIN
// @access  Public
router.post('/shared/:token/setup-pin', async (req, res) => {
    try {
        const { clientName, pin } = req.body;

        // Validate PIN format (4 digits)
        if (!pin || !/^\d{4}$/.test(pin)) {
            return res.status(400).json({ msg: 'PIN must be exactly 4 digits' });
        }

        // Find case by share token
        const caseItem = await Case.findOne({ shareToken: req.params.token })
            .populate('client', 'name');

        if (!caseItem) {
            return res.status(404).json({ msg: 'Invalid case link' });
        }

        // Check if PIN already set
        if (caseItem.pinSetupCompleted) {
            return res.status(400).json({ msg: 'PIN already set for this case' });
        }

        // Verify client name matches (case-insensitive)
        const normalizedInputName = clientName.trim().toLowerCase();
        const normalizedClientName = caseItem.client.name.trim().toLowerCase();

        if (normalizedInputName !== normalizedClientName) {
            return res.status(401).json({ msg: 'Client name does not match' });
        }

        // Hash PIN
        const salt = await bcrypt.genSalt(10);
        const hashedPin = await bcrypt.hash(pin, salt);

        // Save PIN
        caseItem.clientAccessPin = hashedPin;
        caseItem.pinSetupCompleted = true;
        await caseItem.save();

        res.json({ msg: 'PIN set successfully', success: true });

    } catch (err) {
        console.error('PIN setup error:', err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/shared/:token/verify-pin
// @desc    Verify PIN for returning clients
// @access  Public
router.post('/shared/:token/verify-pin', async (req, res) => {
    try {
        const { pin } = req.body;

        // Find case by share token
        const caseItem = await Case.findOne({ shareToken: req.params.token });

        if (!caseItem) {
            return res.status(404).json({ msg: 'Invalid case link' });
        }

        // Check if PIN is set
        if (!caseItem.pinSetupCompleted || !caseItem.clientAccessPin) {
            return res.status(400).json({ msg: 'PIN not set up yet', requiresSetup: true });
        }

        // Verify PIN
        const isMatch = await bcrypt.compare(pin, caseItem.clientAccessPin);

        if (!isMatch) {
            return res.status(401).json({ msg: 'Incorrect PIN' });
        }

        res.json({ msg: 'Authentication successful', success: true });

    } catch (err) {
        console.error('PIN verification error:', err.message);
        res.status(500).send('Server Error');
    }
});

// @route   GET /api/cases/shared/:token/details
// @desc    Get case details for client portal (requires PIN verification)
// @access  Public (but PIN must be verified first)
router.get('/shared/:token/details', async (req, res) => {
    try {
        const caseItem = await Case.findOne({ shareToken: req.params.token })
            .populate('client', 'name email phone address')
            .populate('assignedTo', 'name email')
            .populate('assignedLawyers', 'name email')
            .populate('clientReports.author', 'name');

        if (!caseItem) {
            return res.status(404).json({ msg: 'Invalid case link' });
        }

        // Return case data (excluding sensitive fields)
        const clientCaseData = {
            caseTitle: caseItem.caseTitle,
            caseType: caseItem.caseType,
            subCategory: caseItem.subCategory,
            status: caseItem.status,
            summary: caseItem.summary,
            dateIssueStarted: caseItem.dateIssueStarted,
            clientObjective: caseItem.clientObjective,
            client: caseItem.client,
            parties: caseItem.parties,
            opposingCounselHistory: caseItem.opposingCounselHistory,
            witnesses: caseItem.witnesses,
            inCourt: caseItem.inCourt,
            courtInfo: caseItem.courtInfo,
            clientReports: caseItem.clientReports,
            createdAt: caseItem.createdAt,
            pinSetupCompleted: caseItem.pinSetupCompleted
        };

        res.json(clientCaseData);

    } catch (err) {
        console.error('Fetch case details error:', err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/:id/client-report
// @desc    HOC posts/updates client report
// @access  Private (HOC only)
router.post('/:id/client-report', auth, async (req, res) => {
    try {
        const { subject, content } = req.body;

        if (!subject || !subject.trim() || !content || !content.trim()) {
            return res.status(400).json({ msg: 'Both subject and report content are required' });
        }

        // Check if user is HOC or Lawyer
        const user = await User.findById(req.user.id);
        if (!user || (user.role !== 'HOC' && user.role !== 'Lawyer')) {
            return res.status(403).json({ msg: 'Only HOC and Lawyers can post client reports' });
        }

        const caseItem = await Case.findById(req.params.id);

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Add client report
        caseItem.clientReports.push({
            author: req.user.id,
            subject: subject.trim(),
            content: content.trim(),
            createdAt: new Date()
        });

        await caseItem.save();

        // Populate the newly added report's author
        await caseItem.populate('clientReports.author', 'name');

        // Notify client about the new report
        try {
            if (caseItem.client) {
                await new Notification({
                    recipient: caseItem.client,
                    type: 'client_report_added',
                    message: `New report from HOC for your case: "${caseItem.caseTitle}"`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error notifying client about HOC report:', notifErr.message);
        }

        // Notify all managers
        try {
            const managers = await User.find({ role: 'Manager' });
            const managerNotifications = managers.map(manager => ({
                recipient: manager._id,
                type: 'case_report_added',
                message: `${user.name} (HOC) added a report to case "${caseItem.caseTitle}"`,
                relatedEntity: {
                    entityType: 'Case',
                    entityId: caseItem._id
                }
            }));

            if (managerNotifications.length > 0) {
                await Notification.insertMany(managerNotifications);
            }
        } catch (notifErr) {
            console.error('Error notifying managers about HOC report:', notifErr.message);
        }

        // Notify HOC (confirmation)
        try {
            await new Notification({
                recipient: req.user.id,
                type: 'case_report_added',
                message: `Your report for case "${caseItem.caseTitle}" has been sent to the client`,
                relatedEntity: {
                    entityType: 'Case',
                    entityId: caseItem._id
                }
            }).save();
        } catch (notifErr) {
            console.error('Error notifying HOC about report confirmation:', notifErr.message);
        }

        res.json({
            msg: 'Client report posted successfully',
            report: caseItem.clientReports[caseItem.clientReports.length - 1]
        });

    } catch (err) {
        console.error('Post client report error:', err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/shared/:token/report/:reportId/reply
// @desc    Client posts reply to a report
// @access  Public (with PIN verification)
router.post('/shared/:token/report/:reportId/reply', async (req, res) => {
    try {
        const { pin, content } = req.body;

        if (!pin || !content || !content.trim()) {
            return res.status(400).json({ msg: 'PIN and reply content are required' });
        }

        // Find case by share token
        const caseItem = await Case.findOne({ shareToken: req.params.token })
            .populate('client', 'name');

        if (!caseItem) {
            return res.status(404).json({ msg: 'Invalid case link' });
        }

        // Verify PIN
        if (!caseItem.pinSetupCompleted || !caseItem.clientAccessPin) {
            return res.status(401).json({ msg: 'PIN not set up for this case' });
        }

        const isPinValid = await bcrypt.compare(pin, caseItem.clientAccessPin);
        if (!isPinValid) {
            return res.status(401).json({ msg: 'Invalid PIN' });
        }

        // Find the specific report
        const report = caseItem.clientReports.id(req.params.reportId);
        if (!report) {
            return res.status(404).json({ msg: 'Report not found' });
        }

        // Add client reply
        report.replies.push({
            authorType: 'client',
            authorName: caseItem.client.name,
            content: content.trim(),
            createdAt: new Date()
        });

        await caseItem.save();

        // Notify HOC about client's reply
        try {
            if (caseItem.assignedTo) {
                await new Notification({
                    recipient: caseItem.assignedTo,
                    type: 'case_report_added',
                    message: `${caseItem.client.name} replied to a case report for "${caseItem.caseTitle}"`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            } else {
            }
        } catch (notifErr) {
            console.error('❌ Error notifying HOC about client reply:', notifErr.message);
            console.error('Full error:', notifErr);
        }

        // Notify client (confirmation) that their reply was sent
        try {
            if (caseItem.client && caseItem.client._id) {
                await new Notification({
                    recipient: caseItem.client._id,
                    type: 'client_report_added',
                    message: `Your reply to the case report for "${caseItem.caseTitle}" has been sent`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            } else {
            }
        } catch (notifErr) {
            console.error('❌ Error notifying client about reply confirmation:', notifErr.message);
            console.error('Full error:', notifErr);
        }

        res.json({
            msg: 'Reply posted successfully',
            reply: report.replies[report.replies.length - 1]
        });

    } catch (err) {
        console.error('Client reply error:', err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/:id/report/:reportId/reply
// @desc    HOC posts reply to a report
// @access  Private (HOC only)
router.post('/:id/report/:reportId/reply', auth, async (req, res) => {
    try {
        const { content } = req.body;

        if (!content || !content.trim()) {
            return res.status(400).json({ msg: 'Reply content is required' });
        }

        // Check if user is HOC or Lawyer
        const user = await User.findById(req.user.id);
        if (!user || (user.role !== 'HOC' && user.role !== 'Lawyer')) {
            return res.status(403).json({ msg: 'Only HOC and Lawyers can reply to client reports' });
        }

        const caseItem = await Case.findById(req.params.id);
        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Find the specific report
        const report = caseItem.clientReports.id(req.params.reportId);
        if (!report) {
            return res.status(404).json({ msg: 'Report not found' });
        }

        // Add reply (HOC or Lawyer)
        report.replies.push({
            author: req.user.id,
            authorType: user.role.toLowerCase(), // 'hoc' or 'lawyer'
            authorName: user.name,
            content: content.trim(),
            createdAt: new Date()
        });

        await caseItem.save();

        // Notify client about the reply
        try {
            if (caseItem.client) {
                await new Notification({
                    recipient: caseItem.client,
                    type: 'client_report_added',
                    message: `${user.name} replied to a case report for "${caseItem.caseTitle}"`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error notifying client about reply:', notifErr.message);
        }

        // Notify user (confirmation) that their reply was sent
        try {
            if (req.user.id) {
                await new Notification({
                    recipient: req.user.id,
                    type: 'case_report_added',
                    message: `Your reply to the case report for "${caseItem.caseTitle}" has been sent`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error notifying user about reply confirmation:', notifErr.message);
        }

        res.json({
            msg: 'Reply posted successfully',
            reply: report.replies[report.replies.length - 1]
        });

    } catch (err) {
        console.error('HOC reply error:', err.message);
        res.status(500).send('Server Error');
    }
});

// @route   POST /api/cases/:id/opposing-counsel
// @desc    Update opposing counsel (Add to history)
// @access  Private (Admin, HOC, Superadmin)
router.post('/:id/opposing-counsel', auth, async (req, res) => {
    try {
        const { opposingCounsel } = req.body;

        if (!opposingCounsel || !opposingCounsel.trim()) {
            return res.status(400).json({ msg: 'Opposing counsel name is required' });
        }

        const caseItem = await Case.findById(req.params.id);

        if (!caseItem) {
            return res.status(404).json({ msg: 'Case not found' });
        }

        // Add to history
        caseItem.opposingCounselHistory.push({
            name: opposingCounsel.trim(),
            dateAdded: new Date()
        });

        await caseItem.save();

        // Create automated report
        await createAutomatedReport(
            caseItem._id,
            req.user.id,
            'OpposingCounselUpdate',
            { details: `Opposing counsel updated to ${opposingCounsel}` }
        );

        // Notify stakeholders
        const user = await User.findById(req.user.id);
        const userName = user?.name || 'Someone';
        await notifyCaseStakeholders(
            req.params.id,
            'case_updated',
            `${userName} updated opposing counsel for case "${caseItem.caseTitle}"`,
            req.user.id
        );

        // Notify client about opposing counsel update
        try {
            if (caseItem.client) {
                await new Notification({
                    recipient: caseItem.client,
                    type: 'client_opposing_counsel_updated',
                    message: `Opposing counsel updated for your case: "${caseItem.caseTitle}"`,
                    relatedEntity: {
                        entityType: 'Case',
                        entityId: caseItem._id
                    }
                }).save();
            }
        } catch (notifErr) {
            console.error('Error creating opposing counsel notification:', notifErr.message);
        }

        res.json(caseItem);

    } catch (err) {
        console.error('Update opposing counsel error:', err.message);
        res.status(500).send('Server Error');
    }
});

module.exports = router;
